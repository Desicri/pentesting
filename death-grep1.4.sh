#!/bin/bash
#Death-Grep 1.4 Now with 15% more Death and 5% More grep
#Used for TraceSecurity CSAT, so you don't spend hours going through an Excel file

echo "Put in filename after command!"
echo
IFS="$(printf '\n\t')" #setting the delimiter to ignore spaces
echo "PREPARE FOR DETH-GREP!"
echo

echo "---------------------------------------------------------"
echo "---------------------------------------------------------"
echo "---------------------------------------------------------"
echo "---------------------------------------------------------"
echo

#remove files for cleanup
#------------------------------------------
#make text file of files to remove if this script has been run before
echo "advanced.txt" >>removefiles.txt
echo "intermediate.txt" >>removefiles.txt
echo "evolving.txt" >>removefiles.txt
echo "baseline.txt" >>removefiles.txt
echo "belowbaseline.txt" >>removefiles.txt
echo "categories.txt" >>removefiles.txt
#
#check and remove
for i in $(cat removefiles.txt)
	do [ -e $i ] && rm $i
	done
rm removefiles.txt
#--------------------------------------


#Prerequisites!!!!--------------
#build categories.txt

#Domains, created via Grep and [rinting second col. We remove domains since it is a category in Excel not needed for this 
cat $1 | awk -F "\","\" {'print $2'} | sort -u | uniq | grep -v Domain > categories.txt




#simple function to mark the end in the output files that serve as logs
printvar=" "   #creating a var for Endlines functions. The function adds to files
Endlines(){
	echo "$printvar" >> advanced.txt;
	echo "$printvar" >> intermediate.txt;
	echo "$printvar" >> evolving.txt;
	echo "$printvar" >> baseline.txt;
	echo "$printvar" >> belowbaseline.txt;
	echo " " >> advanced.txt;   #spaces in logs
	echo " " >> intermediate.txt;
	echo " " >> evolving.txt;
	echo " " >> baseline.txt;
	echo " " >> belowbaseline.txt;
	echo " " >> advanced.txt;
	echo " " >> intermediate.txt;
	echo " " >> evolving.txt;
	echo " " >> baseline.txt;
	echo " " >> belowbaseline.txt;
}



#define variables for new AssetBaseline Function

AssetBaseline(){
		echo "---------------------------------------------------------"
		echo $domainVar #just the name of the group/domain. For example "Cyber Risk Management and Oversight"
		echo "---------------------------------------------------------"
		echo
		for i in $componentvar #for loop to get diffrent components, we use a complicated grep/awk sequence to get these
		do
		#echo "$i"
#               Explanation of variables ($textvariable= $1 or .csv passed)    ($domainVar" = 'domain'(domain changes as for loop runs through categories  example Cyber Risk Management and Oversight")
#    the "i" = different companonts with domain   so "patch managemnt" is a comp
#
#FIrst we see if there are any "no" answers in Baseline. We cat the maturity file. We grep for a specific domain (done via for loop of $(cat caterogries) and then print only certian fields of that domain using a very odd separator '","' Not just a comma, but the comma and the quotes. We grep for 'i' which is basicaly the different components. Then we see what is Basleine,and then what is answered "no." 
#If nothing is answered "no" we move on.
#The tricky thing about this program is that I call a for loop to run through the categories, then a program which does a for loop and runs through the compnonets.
		if cat $textvariable | grep "$domainVar" | awk -F "\","\" {'print $4,$5,$7'} | grep "$i" | grep "Baseline" | grep "No" >> /dev/null
			then 
			cat $textvariable | grep "$domainVar" | grep "$i" | grep Baseline | grep "No" | awk -F "\","\" {'print $4,$5,$6'} >> belowbaseline.txt
			echo "$i | Below Baseline";
			echo
			echo " " >> belowbaseline.txt;
				

		elif cat $textvariable | grep "$domainVar" | awk -F "\","\" {'print $4,$5,$7'} | grep "$i" | grep "Evolving" | grep "No" >> /dev/null
			then 
			cat $textvariable | grep "$domainVar" | grep "$i" | grep Evolving | grep "No" | awk -F "\","\" {'print $4,$5,$6'} >> baseline.txt;
			echo "$i | Baseline";
			echo
			echo " " >> baseline.txt;
		
		elif cat $textvariable | grep "$domainVar" | awk -F "\","\" {'print $4,$5,$7'} | grep "$i" | grep "Intermediate" | grep "No" >> /dev/null
			then			
			cat $textvariable | grep "$domainVar" | grep "$i" | grep Intermediate | grep "No" | awk -F "\","\" {'print $4,$5,$6'} >> evolving.txt;
			echo "$i | Evolving";
			echo
			echo " " >> evolving.txt;

		elif cat $textvariable | grep "$domainVar" | awk -F "\","\" {'print $4,$5,$7'} | grep "$i" | grep "Advanced" | grep "No" >> /dev/null
			then 
			cat $textvariable | grep "$domainVar" | grep "$i" | grep Advanced | grep "No" | awk -F "\","\" {'print $4,$5,$6'} >> intermediate.txt;
			echo "$i | Intermediate";
			echo
			echo " " >> intermediate.txt;

		elif cat $textvariable | grep "$domainVar" | awk -F "\","\" {'print $4,$5,$7'} | grep "$i" | grep "Innovative" | grep "No" >> /dev/null
			then 
			cat $textvariable | grep "$domainVar" | grep "$i" | grep Innovative | grep "No" | awk -F "\","\" {'print $4,$5,$6'} >> advanced.txt;
			echo "$i | Advanced";
			echo
			echo " " >> advanced.txt;

		else
			cat $textvariable | grep "$domainVar" | awk -F "\","\" {'print $4,$5,$7'} | grep "$i" | grep "Innovative" | grep "No" >> /dev/null
			echo "$i | Control Not Answered? or Innovative?";
			echo
		fi	
	done;
}

#call it all baby!
if [ -z "$1" ]   #checking to see if parameter was passed                        
     then
        echo "-Type .csv name after the script if you want to use the program"  # Or no parameter passed.
     else
        echo "The .csv is \"$1\"."
	textvariable=$1
	echo
	echo
	for comp in $(cat categories.txt) #this is a text file of the different categories
		do
		printvar="	-----Start of logs for $comp -------"
		Endlines #function uses printvar and adds it to beginning of  all log files
		componentvar=$(cat $1 | grep "$comp" | awk -F "\","\" {'print $4'} | uniq) # Getting components from different categories
		domainVar="$comp"  #this is used by the AssetBaseline function
		AssetBaseline #call function
		printvar="	------------End of logs for $comp ---------------" #function uses printvar and adds it to beginning of  all log files along with a bit of indentation
		Endlines #function
		done
	echo
	echo "Find the Log that matches the organization's actual level and use that for GAP analysis."
	echo "So if the 'Target Maturity Level' is 'Baseline' and the 'Maturity Level' is 'Below Baseline,' find the log named 'Below Baseline'"
fi


echo
#Inherent Risk
echo "------------------------------------------"
echo "Inherent RISK NUMBERS"
echo "------------------------------------------"
if [ -z "$2" ]   #checking to see if parameter was passed                        
     then
        echo "-Type  the second .csv name after the script if you want to use the program for inherent risk numbers"  # Or no parameter passed.
	else
	fileInherent=$2
	cat $fileInherent | tail -n +2 | awk -F "\","\" {'print $5'} | sort -u | uniq > risks.txt
	for i in $(cat risks.txt)
		do
		riskNumber=$(cat $fileInherent | tail -n +2 | awk -F "\","\" {'print $5'} | grep "$i" | wc -l)
		echo "$i | $riskNumber"
	done
	totalNumber=$(cat $fileInherent | tail -n +2 | awk -F "\","\" {'print $5'} | wc -l)
	echo "Total | $totalNumber"
	
fi





