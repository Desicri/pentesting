#!/bin/bash
#EPT Script   
#To begin just make a text called ips.txt in the folder from which you run this script. Make the ips.txt file grepable and nmap friendly (This means one line per ip range.)
#Example for ips.txt:
#192.168.1.1-254
#192.168.2.5-15

#Zone Transfer function
#
zoneTransfer(){
	for i in $(host -t ns $1 | cut -d " " -f 4);
        do
        host -t axfr $1 $i
        done
	return 0;
}


#HARVESTER FUNCTION and ZONE TRANSFER CALL
#Checks to see if you put the domain name after the script. If so you get a harvester and zone transfer attempt. 
#Basically, did you put anyhting after the name of the script?
#
harvestcheck2 () {
   if [ -z "$1" ]                           
     then
        echo "-Type domain name after the script if you want to run harvester here-"  # Or no parameter passed.
     else
        echo "-The domain name is \"$1\".-"
        echo "Performing Harvest..."
        theharvester -d $1 -b all -h -f harvestfile
	echo
	
	#creates two files, one a userfile composed from harvester names, the other a passfile with two passwords.
	#these files are used for the metasploit OWA brute force attack
     	cat harvestfile.xml | tr ">" '\n' | grep @ | cut -d "<" -f 1 | sort -u > userfile  
     	echo 'password!' > passfile; 
     	echo 'winter2016!@#' >> passfile;
	echo

	#calls a function to check for zone transfers
	echo "Checking for zone transfers..."
        zoneTransfer $1  
   fi
   return 0
}


#CALLING HARVEST2 FUNCTION
#Calling function to check if a parameter was passed. If nothing is passed this is skipped.
#
echo
harvestcheck2 "$1"


#IP CHECK
#Creating an array via ips.txt. This text file should be grappable and nmap friendly
#This array tells us our ip addresses just in case we screwed something up.
#
readarray iparray < ips.txt 
echo "The IP addresses are:"
for i in ${iparray[@]} 
do
	echo $i;
done
echo


#NMAP TCP SCANS (no version)
#
echo "Beginning nmap -sSV -Pn --top-ports 2000 -iL ips.txt -oG nmaptcp.txt;'";
echo
nmap -sSV -Pn --top-ports 2000 -iL ips.txt -oG nmaptcp.txt;


#NMAP PARSER (TCP)
#This next line needs to be wherever your trace_nmapparser.py script is.
#
/usr/local/sbin/trace_nmapparser.py nmaptcp.txt;  
echo


#NMAP UDP SCANS
#
echo "Beginning NMAP nmap command 'nmap -sU -Pn --top-ports 50 -iL ips.txt -oG nmapudp.txt'"
nmap -sU -Pn --top-ports 50 -iL ips.txt -oG nmapudp.txt
/usr/local/sbin/trace_nmapparser.py nmapudp.txt
echo


#LIST OF INDIVIDUATED IPS
# This will create a list of each IP in a grepable format. It serves the same function as Prips
#
grep "Host:" nmapudp.txt nmaptcp.txt| cut -d " " -f 2 | sort -u > allhosts.txt;  
echo


#PING SWEEP
#Ping sweep... Waits 1 second before moving on.
#
echo "Doing Ping Sweep";
echo "------------------List of IPs found by ping--------------------"
touch pinged_ips.txt;
readarray alliparray < allhosts.txt;
for i in ${alliparray[@]}
do 
	ping -c 1 -W 1 $i | grep -B 1 "1 received" | grep "ping" | cut -d " " -f 2 | tee -a pinged_ips.txt;
done


#CREATING 443 ADDRESSES
#
echo "------------------List of open 443 addresses------------------" 
grep -F "ssl|http" nmaptcp.txt | grep open | cut -d " " -f 2 | uniq | sort -n | tee -a ssl_ips.txt
echo "------------------end 443 list------------------" 


#SSLSCANS
#This portion of the script outputs your SSL scans to the screen and outputs each to a file using the 'tee' command. 
#
readarray array443 < ssl_ips.txt;
for i in ${array443[@]}
do 
	sslscan $i | tee $i."sslscan"
done
echo


#CREATING UDP DNS FILE
#
echo "Creating UDP DNS list and testing for DNS/UDP 53 Snooping"
cat nmapudp.txt | grep -F "53/open" | cut -d " " -f 2 | uniq > dnsUDPips.txt
echo


#TESTING UDP DNS
#
if [[ -s dnsUDPips.txt ]]  #if the file is empty it deletes the results, else the nmap dns caching script is run
	then 
	rm -f dnsUDPips.txt
	echo "No UDP 53 ports found"
	else
	nmap -sU -p 53 --script dns-cache-snoop.nse -Pn -iL dnsUDPips.txt | tee -a dnsCacheSnoopTestUDP.txt	
fi
echo


#NTP SERVER TESTS
#
echo "Testing for NTP servers"
cat nmapudp.txt nmaptcp.txt | grep -F "123/open" | cut -d " " -f 2 | uniq | tee -a ntpUDPips.txt
if [[ -s ntpUDPips.txt ]]
then
readarray ntpparray < ntpUDPips.txt
for i in ${ntpparray[@]}
do 
echo
echo "NTPQ test for $i"
echo "-----------------------------------------"
echo
echo "ntpq -c readvar $i"
ntpq -c readvar $i | tee -a ntptest.txt
echo "ntpq -c readvar -c peers $i"
ntpq -c readvar -c peers -n $i | tee -a ntptest.txt #the -a in tee appends
echo 
done
fi
echo


#IKE-SCANS
#
cat nmapudp.txt | grep "isakmp" | cut -d " " -f 2 >ikescanips.txt
if [[ -s ikescanips.txt ]]
then 
echo "Running IKE-SCANS..."
readarray ikearray < ikescanips.txt
for i in ${ikearray[@]}
do
echo "ike-scan -A on $i..."
ike-scan -A $i
echo
done
fi
echo

#Firefox Open Websites and Takes Screenshots
#
cat nmaptcp.txt | grep -E "80/open" | cut -d " " -f 2 > http.txt
if [[ -s http.txt ]]
then
	webarray=$(cat http.txt)
	firefox &
	sleep 2
	for i in $webarray; 
	do
	firefox http://$i & 2>/dev/null
	cutycapt --url=http://$i --out="http $i.png" --insecure
	sleep 1
	done
fi

sleep 2

if [[ -s ssl_ips.txt ]]
then
	webarray=$(cat ssl_ips.txt)
	firefox &
	sleep 2
	for i in $webarray; 
	do
	firefox https://$i & 2>/dev/null
	cutycapt --url=https://$i --out="https $i.png" --insecure
	sleep 1
	done
fi


#echo "Doing Ping Sweep";
#echo "------------------List of IPs found by ping--------------------"
#touch pinged_ips.txt;
#readarray alliparray < allhosts.txt;
#for i in ${alliparray[@]}
#do 
#	ping -c 1 -W 1 $i | grep -B 1 "1 received" | grep "ping" | cut -d " " -f 2 | tee pinged_ips.txt;
#done

#for i in array
#if [[ -s 
#clear
#gnome-screenshot -w -b -f blah.png

#echo "scan for snmp and output to a text file and runa  version scan"
#cat nmapudp | grep -F "open/udp" | grep snmp | cut -d " " -f 2 | uniq | tee udpSnmp.txt
#nmap -sUV -Pn -p 161 -iL udp.txt -oG snmp.txt




#eyewitness -f /root/Desktop/EPT/xplore/ssl_ips.txt --web --prepend-http
#grep -B 1 is a command that gives you the grep line and 1 line before. Dang useful. "Cut" can set a delimiter as nearly anything and then you can set the -f <field> you want to print.
#readarray array443 < "443.txt"
